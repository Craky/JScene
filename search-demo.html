<!doctype html>
<html>
<head>
<!--script type="text/javascript" src="tweets.js"></script></script-->
<script type="text/javascript" src="sample-tweets.js"></script></script>
</head>
 
<body>
 
<script>
var sep = "+";
var db;
 
function indexedDBOk() {
 return "indexedDB" in window;
}
 
document.addEventListener("DOMContentLoaded", function() {
  if (!indexedDBOk) return;

  //indexedDB.deleteDatabase("index");

  var openRequest = indexedDB.open("index", 1);

  openRequest.onupgradeneeded = function(e) {
    var thisDB = e.target.result;

    if (!thisDB.objectStoreNames.contains("postings")) {
      thisDB.createObjectStore("postings");
    }

    if (!thisDB.objectStoreNames.contains("df")) {
      thisDB.createObjectStore("df");
    }
  }

  openRequest.onsuccess = function(e) {
    db = e.target.result;

    document.querySelector("#indexButton").addEventListener("click", index, false);
    document.querySelector("#searchButton").addEventListener("click", search, false);
    document.querySelector("#statsButton").addEventListener("click", stats, false);
    document.querySelector("#dfButton").addEventListener("click", buildDf, false);

    console.log("Initialization complete!");
  }
 
  openRequest.onerror = function(e) {
    // Do something for the error
  }
 
}, false);

function stats(e) {
  var query = document.querySelector("#query").value;
  var transaction = db.transaction(["postings"], "readonly");
  var store = transaction.objectStore("postings");

  var request = store.count();
  request.onsuccess = function(e) {
    console.log("Total number of entries: " + e.target.result);
    return;
  }
}

// IDF

function buildDf(e) {
  var DF = {};
  for (var i=0; i<tweets.length; i++) {
    var tokens = tokenizeToHistogram(tweets[i].text);
    for (var t in tokens) {
      if (t in DF) {
        DF[t]++;
      } else {
        DF[t] = 1;
      }
    }
  }

  var tuples = [];
  for (var key in DF) tuples.push([key, DF[key]]);

  insert_df(0, tuples);
}

function insert_df(i, tuples) {
  var transaction = db.transaction(["df"],"readwrite");
  var store = transaction.objectStore("df");
  var request = store.add(tuples[i][1], tuples[i][0]);
 
  //console.log(tuples[i][1], tuples[i][0]);
  request.onerror = function(e) {
    console.log("Error", e.target.error.name);
  }

  request.onsuccess = function(e) {
    if (i < tuples.length-1) {
      insert_df(i+1, tuples);
    } else {
      console.log("inserted " + tuples.length + " dfs");
    }
  }
}


// Querying

var query_terms;
var DF = {};

function search(e) {
  query_terms = document.querySelector("#query").value.split(" ");

  for (var i=0; i<query_terms.length; i++) {
    var transaction = db.transaction(["df"],"readonly");
    var store = transaction.objectStore("df");
    var request = store.get(query_terms[i]);
 
    request.onerror = function(e) {
      console.log("Error", e.target.error.name);
    }

    request.onsuccess = (function(query) { return function(e) {
      DF[query] = e.target.result;
      console.log(query + ", df=" + e.target.result);
    }})(query_terms[i]);
  }

  var query = query_terms[0];
  console.log("query term[0]: " + query);
  var transaction = db.transaction(["postings"], "readonly");
  var store = transaction.objectStore("postings");

  var startTime = new Date().getTime();

  //console.log("Start time: " + startTime);

  var range = IDBKeyRange.bound(query + sep, query + ".");
  var cursor = store.openCursor(range);

  var cnt = 0;

  var results = {};
  cursor.onsuccess = function(e) {
    var res = e.target.result;
    if (res) {
      var parts = res.key.split(sep);
    }

    if ( res && parts[0] == query ) {
      results[parts[1]] = res.value * Math.log(tweets.length/DF[parts[0]]);;
      cnt++;
      res.continue();
    }

    if ( !res || parts[0] != query ) {
      var end = new Date().getTime();
      console.log(Object.keys(results).length + " hits in " + (end-startTime) + "ms");
      //console.log(results);

      if (query_terms.length > 1 ) {
        search_cont(1, results);     
      } else {
        print_results(results, 10);
      }
    }
  };

}

function search_cont(n, results) {
  var query = query_terms[n];
  console.log("query term[" + n + "]: " + query);

  var transaction = db.transaction(["postings"], "readonly");
  var store = transaction.objectStore("postings");

  var startTime = new Date().getTime();

  var range = IDBKeyRange.bound(query + sep, query + ".");
  var cursor = store.openCursor(range);

  var cnt = 0;

  cursor.onsuccess = function(e) {
    var res = e.target.result;
    if (res) {
      var parts = res.key.split(sep);
    }

    if ( res && parts[0] == query ) {
      if ( parts[1] in results) {
        results[parts[1]] += res.value * Math.log(tweets.length/DF[parts[0]]);
      }

      cnt++;
      res.continue();
    }

    if ( !res || parts[0] != query ) {
      var end = new Date().getTime();
      console.log((end-startTime) + "ms");
      if ( n < query_terms.length-1 ) {
        search_cont(n+1, results);     
      } else {
        print_results(results, 10);
      }
    }
  };
}


// http://stackoverflow.com/questions/5199901/how-to-sort-an-associative-array-by-its-values-in-javascript
function print_results(results, k) {
  var tuples = [];

  for (var key in results) tuples.push([key, results[key]]);

  tuples.sort(function(a, b) {
    return a[1] > b[1] ? -1 : (a[1] < b[1] ? 1 :
      a[0] < b[0] ? 1 : -1);
  });

  for (var i = 0; i < k && i<tuples.length; i++) {
    var key = tuples[i][0];
    var value = tuples[i][1];

    console.log(key, value);
  }
}

// Indexing code

var gNumTweets = 0;
var gNumTokens = 0;

var gIndexStartTime;

function index(e) {
  gIndexStartTime = new Date().getTime();
  index_tweet(0);
}

function index_tweet(i) {
  gNumTweets++;
  var tokens = tokenizeToHistogram(tweets[i].text);

  console.log(tweets[i].id_str, tokens);

  var tuples = [];
  for (var key in tokens) tuples.push([key, tokens[key]]);

  if ( tuples.length == 0 ) {
    // NOTES: corner case here, won't work if last tweet is empty.
    index_tweet(i+1)
  } else {
    index_term(i, 0, tuples);
  }
}

function index_term(i, j, tokens) {
  gNumTokens++;
  var transaction = db.transaction(["postings"],"readwrite");
  var store = transaction.objectStore("postings");

  // Remember to use id_str because of Javascript precision issues.
  var t = tokens[j][0] + sep + tweets[i].id_str;

  var request = store.add(tokens[j][1], t);
 
  request.onerror = function(e) {
    console.log("Error", e.target.error.name);
    // Need better error trapping up this will do for now.
    index_tweet(i+1)
  }

  request.onsuccess = function(e) {
    //console.log("ok: " +  t);
    if (j < tokens.length-1) {
      index_term(i, j+1, tokens);
    } else if (i < tweets.length-1) {
      index_tweet(i+1)
    } else {
      var end = new Date().getTime();
      console.log("Number of tweets indexed: " + gNumTweets);
      console.log("Number of tokens indexed: " + gNumTokens);
      //console.log("Start time: " + gIndexStartTime);
      //console.log("End time: " + end);
      console.log("Indexing time: " + (end - gIndexStartTime) + "ms");
    }
  }
}

function tokenizeToHistogram(s) {
  var raw = s.split(' ');

//  raw = raw.map(function(x) { return x.replace(/(^[^A-Za-z]+)|([^A-Za-z]+$)/g, "").toLowerCase()})
//           .filter(function(x) { return x.length > 0 ? true : false; });

  var tokens = {};

  for (var n=0; n<raw.length; n++) {
    if ( raw[n] in tokens ) {
      tokens[raw[n]]++;
    } else {
      tokens[raw[n]] = 1;
    }
  }

  return tokens;
}

// indexedDB.deleteDatabase('todos')
</script>
 
<button id="indexButton">Build Index</button>
<button id="statsButton">Get Stats</button>
<button id="dfButton">Build DF</button>

<p>
<input type="text" id="query" placeholder="query">
<button id="searchButton">Search</button>
</p>

</body>
</html>
 


